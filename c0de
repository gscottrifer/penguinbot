
#include "sensors.h"

//Behavior primitive functions
int check_escape_conditions();
int check_avoid_conditions();
int check_approach_conditions();
int check_seekcolor_conditions();
void seekcolor();
void escape();
void avoid();
void approach();
void straight_cruise();
void pick_up();
void return_nest();
void stop();
//Motor Control Function
void drive(float left, float right, float delay_seconds);

//*************************************************** Global Constant Declarations ****************************************************//
const int FRONT_BUMP = 0;
const int BACK_BUMP = 1;//15;
const int LEFT_PHOTO = 2;
const int RIGHT_PHOTO = 3;
const int LEFT_IR = 4;
const int RIGHT_IR = 5;
const int LEFT_MOTOR = 0;
const int RIGHT_MOTOR = 3;

const int YELLOW_CH = 0;
const int RED_CH = 1;
const int BLUE_CH = 2;
const int GREEN_CH = 3;

const float SERVO_MAX = 2047.0;
const float TOP_SPEED = 1023.0;//100;
//Boolean Constants
//This dialect of C does not have boolean data types, so we're faking it
//according to convention: true is non-zero, 	sually 1, and false is 0.
const int TRUE = 1;
const int FALSE = 0;
//*************************************************** Function Definitions ****************************************************//
int main() 
{
int i;
	enable_servos();
		
	while(1){ 
	if(check_escape_conditions()){
			
			escape();
		}
	else if(check_seekcolor_conditions()){
				seekcolor();
				
		}
	
	else if(check_avoid_conditions()){
		printf("avoid\n");
		avoid();
	}
	
	else{straight_cruise();}
	
	}
//printf-Prints behavior the robot is currently executing
return 0;
}
/******************************************************/
int check_escape_conditions(){
	int bump_threshold = 0;
	int bump_max = 400;
	int front_bump_value = analog10(FRONT_BUMP);
	
	if(front_bump_value >= bump_threshold && front_bump_value <= bump_max){
		return TRUE;
	}else{
		return FALSE;
	}
}

/******************************************************/
void escape(){
	int bump_threshold = 250;
	int bump_max = 400;
	int front_bump_value = analog10(FRONT_BUMP);
	//printf("EscapeFrontBump()\n");
	if(front_bump_value < bump_threshold){
		//drive(-0.25, 0.75, 0.50);
		drive(-0.0, -0.90, 0.50);
		//printf("drive(-0.25, -0.75, 1.5);\n");
	}
	else if(front_bump_value >= bump_threshold && front_bump_value <= bump_max){
		//drive(0.75, -0.25, 0.50);
		drive(-0.90, -0.0, 0.50);
		//printf("drive(-0.75, -0.25, 1.5);\n");
	}

}

/******************************************************/
int check_seekcolorconditions(){
}
/******************************************************/
void seekcolor(){
}
/******************************************************/

int check_avoid_conditions(){
	int left_ir_value;
	int right_ir_value;
	
	left_ir_value = analog_et(LEFT_IR);
	right_ir_value = analog_et(RIGHT_IR);
	
	if(left_ir_value > avoid_threshold || right_ir_value > avoid_threshold){
		return TRUE;
	}else{
		return FALSE;
	}
}

/******************************************************/
void pick_up(){
}
/******************************************************/
void return_nest(){
}
/******************************************************/
void avoid(){
	int left_ir_value;
	int right_ir_value;
	
	left_ir_value = analog_et(LEFT_IR);
	right_ir_value = analog_et(RIGHT_IR);
	
	if(left_ir_value > avoid_threshold){
		drive(0.5, -0.5, 0.1);
	}
	
	else if(right_ir_value > avoid_threshold){
		drive(-0.5, 0.5, 0.1);
	}
}

/******************************************************/
void straight_cruise(){
	//drive(1.0, 1.0, 0.5);
	drive(0.40, 0.40, 0.5);
}
/******************************************************/
void stop(){
	drive(0.0, 0.0, 0.25);
}
/******************************************************/
void drive(float left, float right, float delay_seconds){
	float left_speed;
	float right_speed;
	
	delay_seconds *= 1000;
	//printf("left = %f, right = %f, TOP_SPEED = %f\n", left, right, TOP_SPEED);
	
	right_speed = TOP_SPEED - (right * TOP_SPEED);
	left_speed  = TOP_SPEED + (left * TOP_SPEED);
	
	//printf("left_speed = %f, right_speed = %f\n", left_speed, right_speed);	
	set_servo_position(LEFT_MOTOR, left_speed);
	set_servo_position(RIGHT_MOTOR, right_speed);
	msleep(delay_seconds);
	//disable_servos();
}
/******************************************************/







